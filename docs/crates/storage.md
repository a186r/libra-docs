---
id: storage
title: Storage
custom_edit_url: https://github.com/libra/libra/edit/master/storage/README.md
---

存储模块为Libra区块链上的所有数据集以及Libra Core内部使用的必要数据提供可靠和高效的持久存储。

## 概要

存储模块旨在实现下面两个主要目的：

1. 保留区块链数据，特别是验证方通过共识协议达成一致的交易及其输出。
2. 为任何查询提供一个带有Merkle证明的响应，该查询要求部分区块链数据。如果客户端获得了正确的root hash，则可以轻松地验证响应的完整性。

Libra 区块链可以被视为Merkle树，包含以下组件：

![data](assets/data.png)

### 历史分类账

分类帐历史由Merkle累加器表示。 每次将交易 `T` 添加到区块链时, 一个包含交易 `T` 的 *TransactionInfo* 结构，执行 `T` 后状态Merkle树的root hash和生成交易Merkle树的root hash 通过 `T` 附加到累加器。

### 分类账状态

每个版本的分类帐状态由稀疏Merkle树表示，该树具有所有帐户的状态。 密钥是地址的256位散列值，它们的对应值是序列化为二进制blob的整个帐户的状态。 虽然大小为 `2^256` 的树是一个难以处理的表示方式，但完全由空节点组成的子树将替换为占位符值，而由一个叶子组成的子树将替换为单个节点。

然每个 *TransactionInfo* 结构指向不同的状态树，但新树可以重用前一树的未更改部分，从而形成持久数据结构。

### 事件

每个交易发出一个事件列表，这些事件构成一个Merkle累加器。与状态Merkle树类似，交易的事件累加器的root hash记录在相应的 *TransactionInfo* 模块。


### Ledger Info and Signatures

A *LedgerInfo* structure that has the root hash of the ledger history
accumulator at some version and other metadata is a binding commitment to
the ledger history up to this version. Validators sign the corresponding
*LedgerInfo* structure every time they agree on a set of transactions and their
execution outcome. For each *LedgerInfo* structure that is stored, a set of
signatures on this structure from validators are also stored, so
clients can verify the structure if they have obtained the public key of each
validator.

## Implementation Details

The storage module uses [RocksDB](https://rocksdb.org/) as its physical storage
engine. Since the storage module needs to store multiple types of data, and
key-value pairs in RocksDB are byte arrays, there is a wrapper on top of RocksDB
to deal with the serialization of keys and values. This wrapper enforces that all data in and
out of the DB is structured according to predefined schemas.

The core module that implements the main functionalities is called *LibraDB*.
While we use a single RocksDB instance to store the entire set of data, related
data are grouped into logical stores &mdash; for example, ledger store, state store,
and transaction store, etc.

For the sparse Merkle tree that represents ledger state, we optimize the disk
layout by using branch nodes with 16 children that represents 4-level subtrees
and extension nodes that represents a path without branches. However, we still
simulate a binary tree when computing the root hash and proofs. This modification
results in proofs that are shorter than the ones generated by Ethereum's Merkle
Patricia tree.

## How is this module organized?
```
    storage
          └── accumulator      # Implementation of Merkle accumulator.
          └── libradb          # Implementation of LibraDB.
          └── schemadb         # Schematized wrapper on top of RocksDB.
          └── scratchpad       # In-memory representation of Libra core data structures used by execution.
          └── sparse_merkle    # Implementation of sparse Merkle tree.
          └── state_view       # An abstraction layer representing a snapshot of state where the Move VM reads data.
          └── storage_client   # A Rust wrapper on top of GRPC clients.
          └── storage_proto    # All interfaces provided by the storage module.
          └── storage_service  # Storage module as a GRPC service.
```
